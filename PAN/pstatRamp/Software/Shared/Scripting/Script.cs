/*************************************************************************************************/
/*   Project : IO                                                                                */
/*   Authors : Chris Dawber                                                                      */
/* Reviewers :                                                                                   */
/*************************************************************************************************/

using System;
using System.IO;
using System.Linq;
using System.Collections.Generic;
using System.Xml.Serialization;
using IO.Analysis;

namespace IO.Scripting
{
    /// <summary>
    /// Script object
    /// </summary>
    public class Script : IScript
    {
        /// <summary>
        /// The owning scrips object
        /// </summary>
        private Scripts owner = null;

        /// <summary>
        /// The script
        /// </summary>
        private string scriptValue = null;

        /// <summary>
        /// List of script errors
        /// </summary>
        private List<ScriptError> errors = null;

        /// <summary>
        /// Dictionary of variables generated by this script
        /// </summary>
        private Dictionary<string, IScriptVariable> newVariables = null;

        /// <summary>
        /// Set of used variables
        /// </summary>
        private HashSet<string> usedVariables = null;

        /// <summary>
        /// List of children
        /// </summary>
        private HashSet<string> children = null;

        /// <summary>
        /// The script
        /// </summary>
        [XmlIgnore]
        public override string Value
        {
            get
            {
                return scriptValue;
            }
            set
            {
                // Set the value
                scriptValue = value;

                // Clear any errors
                errors = new List<ScriptError>();

                // Clear any children
                children = new HashSet<string>(StringComparer.CurrentCultureIgnoreCase);

                // Clear any variables
                newVariables = new Dictionary<string, IScriptVariable>();
                usedVariables = new HashSet<string>();

                // Parse the script
                ParseScript();
            }
        }

        /// <summary>
        /// Enumeration of script errors
        /// </summary>
        [XmlIgnore]
        public override IEnumerable<ScriptError> Errors 
        {
            get
            {
                return errors;
            }
        }

        /// <summary>
        /// Dictionary of variables generated by this script
        /// </summary>
        [XmlIgnore]
        public override IDictionary<string, IScriptVariable> NewVariables 
        {
            get
            {
                return newVariables;
            }
        }

        /// <summary>
        /// Enumeration of variables used by this script
        /// </summary>
        [XmlIgnore]
        public override IEnumerable<string> UsedVariables
        {
            get
            {
                return usedVariables;
            }
        }

        /// <summary>
        /// Enumeration of script children
        /// </summary>
        [XmlIgnore]
        public override IEnumerable<string> Children
        {
            get
            {
                return children;
            }
        }

        /// <summary>
        /// Default constructor
        /// </summary>
        /// <param name="scriptName">The name</param>
        /// <param name="scriptsOwner">The owner</param>
        public Script(string scriptName, Scripts scriptsOwner)
        {
            Name = scriptName;
            owner = scriptsOwner;
        }

        /// <summary>
        /// Add an error
        /// </summary>
        /// <param name="description">The description</param>
        /// <param name="line">The line number</param>
        internal void AddError(string description, int line)
        {
            // Add the error to the private list
            errors.Add(new ScriptError() { Description = description, Line = line });
        }

        /// <summary>
        /// Add a consistency error
        /// </summary>
        /// <param name="description">The description</param>
        /// <param name="line">The line number</param>
        internal void AddConsistencyError(string description)
        {
            if (errors.Exists(x => (x.Line == -1) && (x.Description == description)) == false)
            {
                // Add the error to the private list
                errors.Add(new ScriptError() { Description = description, Line = -1 });
            }
        }

        /// <summary>
        /// Clear consistency errors
        /// </summary>
        internal void ClearConsistencyErrors()
        {
            // Loop through an array of all the consitency errors
            foreach (var error in errors.Where(x => x.Line == -1).ToArray())
            {
                // Remove them from the list
                errors.Remove(error);
            }
        }

        /// <summary>
        /// Add a new variable
        /// </summary>
        /// <param name="name">The variable name</param>
        /// <param name="type">The variable type</param>
        /// <param name="value">The variable value</param>
        /// <returns>False if the type would be redefined, otherwise true</returns>
        internal bool AddVariable(string name, ScriptVariableType type, object value = null)
        {
            // Check for an existing variable
            IScriptVariable existingVariable;

            if (newVariables.TryGetValue(name.ToLower(), out existingVariable))
            {
                // Check for a redefinition
                if ((existingVariable.VariableType != type) ||
                    (existingVariable.Value != value))
                {
                    return false;
                }
            }
            else
            {
                // Add the new variable
                newVariables[name.ToLower()] = new ScriptVariable()
                    {
                        VariableType = type,
                        Value = value,
                    };
            }

            return true;
        }

        /// <summary>
        /// Parse the script looking for errors
        /// </summary>
        private void ParseScript()
        {
            // Split the script on new line characters
            var lines = scriptValue.Split(new string[] { "\r\n" }, StringSplitOptions.None);
            
            // Initialise the line number
            int lineNumber = 0;

            // Parse the lines reccursively
            string command = ParseLines(lines, ref lineNumber);
     
            // Check for an unexpected termination command
            if (command != null)
            {
                // Report an unexpected command
                AddError("Unexpected command '" + command + "'", lineNumber - 1);
            }
        }

        /// <summary>
        /// Parse the script lines using the lineNumber as a pointer
        /// Return at the end of the lines or if a stack frame is terminated
        /// </summary>
        /// <param name="lines">The script lines</param>
        /// <param name="lineNumber">The line number</param>
        /// <param name="topCommand">The command that created the stack frame</param>
        /// <returns>A stack frame command or null if the end of the file is reached</returns>
        private string ParseLines(string[] lines, ref int lineNumber, string topCommand = null)
        {
            // Parse on through the file
            while (lineNumber < lines.Length)
            {
                // Parse the line
                string command = ParseLine(lines[lineNumber], lineNumber++);

                // Check for a stack frame command
                if (command != null)
                {
                    // Check for an else
                    if (command == "else")
                    {
                        // Else must follow if
                        if (topCommand != "if")
                        {
                            // Report an unexpected else
                            errors.Add(new ScriptError()
                            {
                                Description = "Unexpected 'else'",
                                Line = lineNumber - 1
                            });
                        }
                        else
                        {
                            // Return this else and end the starck frame
                            return command;
                        }
                    }
                    else if (command == "end")
                    {
                        // Else must follow if
                        if (topCommand == "if")
                        {
                            // Report an unexpected else
                            errors.Add(new ScriptError()
                            {
                                Description = "Unexpected 'end'",
                                Line = lineNumber - 1
                            });
                        }
                        else
                        {
                            // Return this end and end the stack frame
                            return command;
                        }
                    }
                    else if (command == "endif")
                    {
                        // Else must follow if
                        if ((topCommand != "if") && (topCommand != "else"))
                        {
                            // Report an unexpected else
                            errors.Add(new ScriptError()
                            {
                                Description = "Unexpected 'endif'",
                                Line = lineNumber - 1
                            });
                        }
                        else
                        {
                            // Return this end and end the stack frame
                            return command;
                        }
                    }
                    else if (command == "if")
                    {
                        // Parse the next stack frame
                        var nextCommand = ParseLines(lines, ref lineNumber, command);

                        // Check for an else
                        if (nextCommand == "else")
                        {
                            // Parse the else part of the stack frame
                            nextCommand = ParseLines(lines, ref lineNumber, nextCommand);
                        }

                        // The next command must be an end
                        if (nextCommand != "endif")
                        {
                            // Report an unterminated construct
                            errors.Add(new ScriptError()
                            {
                                Description = "Unterminated '" + command + "'",
                                Line = lineNumber - 1
                            });

                            return null;
                        }
                    }
                    else if (command == "begin")
                    {
                        // Parse the next stack frame
                        var nextCommand = ParseLines(lines, ref lineNumber, command);

                        // The next command must be an end
                        if (nextCommand != "end")
                        {
                            // Report an unterminated construct
                            errors.Add(new ScriptError()
                            {
                                Description = "Unterminated '" + command + "'",
                                Line = lineNumber - 1
                            });

                            return null;
                        }
                    }
                }
            }

            return null;
        }

        /// <summary>
        /// Parse the passed script line, generating errors where appropriate
        /// </summary>
        /// <param name="line">The script line</param>
        /// <param name="lineNumber">The line number</param>
        /// <returns>A stack frame command or null if the end of the file is reached</returns>
        private string ParseLine(string line, int lineNumber)
        {
            // Tokenise the string
            string error;
            var tokens = line.Tokenise(out error);

            // Check for an error
            if (tokens == null)
            {
                // Add the error
                AddError(error, lineNumber);
                return null;
            }
            
            if (tokens.Count == 0)
            {
                // This is an empty line
                return null;
            }

            // Get the command
            var command = tokens[0].ToLower();
            
            if (command == "map")
            {
                IScriptVariable variable;

                if (tokens.Count != 3)
                {
                }
                else if (newVariables.TryGetValue(tokens[2].ToLower(), out variable) == true)
                {
                    // Report an invalid map statement
                    AddError("'map' statement redefines variable '" + tokens[2] + "'", lineNumber);
                }
                else if (AddVariable(tokens[2], ScriptVariableType.Alias, tokens[1]) == false)
                {
                    // Report an invalid map statement
                    AddError("'map' statement redefines variable '" + tokens[2] + "'", lineNumber);
                }
            }
            else if (command == "name")
            {
                if (tokens.Count != 3)
                {
                    // Report an invalid name statement
                    AddError("'name' statement with with wrong number of arguments", lineNumber);
                }
                else if (owner.AddDeviceName(tokens[1], tokens[2]) == false)
                {
                    // Report an invalid name statement
                    AddError("'name' statement with with invalid argument '" + tokens[1] + "'", lineNumber);
                }
            }
            else if (command == "res")
            {
                if (tokens.Count < 3)
                {
                    // Report an invalid res statement
                    AddError("'res' statement with too few arguments", lineNumber);
                }
                else
                {
                    // Add the used variable
                    usedVariables.Add(tokens[1].ToLower());

                    // Check the directive
                    var directive = tokens[2].ToLower();

                    if (directive == "hold")
                    {
                        int pressure;
                        int maxPressure;
                        int time;

                        if (tokens.Count < 6)
                        {
                            // Report an invalid res statement
                            AddError("'res' hold statement with too few arguments", lineNumber);
                        }
                        else if (int.TryParse(tokens[3], out pressure) == false)
                        {
                            // Report an invalid res statement
                            AddError("'res' hold statement with invalid pressure argument '" + tokens[3] + "'",
                                lineNumber);
                        }
                        else if ((int.TryParse(tokens[4], out maxPressure) == false) || 
                                 (pressure >= maxPressure))
                        {
                            // Report an invalid res statement
                            AddError("'res' hold statement with invalid max pressure argument '" + tokens[4] + "'",
                                lineNumber);
                        }
                        else if ((int.TryParse(tokens[5], out time) == false) ||
                                (time < 0))
                        {
                            // Report an invalid res statement
                            AddError("'res' hold statement with invalid time argument '" + tokens[5] + "'",
                                lineNumber);
                        }
                        else if (tokens.Count > 7)
                        {
                            // Report an invalid res statement
                            AddError("'res' hold statement with too many arguments", lineNumber);
                        }
                        else if (tokens.Count == 7)
                        {
                            if (AddVariable(tokens[6], ScriptVariableType.Flag) == false)
                            {
                                // Report an invalid map statement
                                AddError("'res' hold statement redefines variable '" + tokens[6] + "'", lineNumber);
                            }
                            else
                            {
                                // Add it as a used variable
                                usedVariables.Add(tokens[6].ToLower());
                            }
                        }
                    }
                    else if (directive == "dump")
                    {
                        if (tokens.Count > 3)
                        {
                            // Report an invalid res statement
                            AddError("'res' dump statement with too many arguments", lineNumber);
                        }
                    }
                    else
                    {
                        // Report an invalid res statement
                        AddError("'res' statement with invalid argument '" + tokens[2] + "'", lineNumber);
                    }
                }
            }
            else if (command == "valve")
            {
                if (tokens.Count != 3)
                {
                    // Report an invalid res statement
                    AddError("'valve' statement with wrong number of arguments", lineNumber);
                }
                else
                {
                    // Check the directive
                    var directive = tokens[2].ToLower();

                    if ((directive != "on") && (directive != "off"))
                    {
                        // Report an invalid res statement
                        AddError("'valve' statement with invalid argument '" + tokens[2] + "'", lineNumber);
                    }
                    else
                    {
                        // Add the used variable
                        usedVariables.Add(tokens[1].ToLower());
                    }
                }
            }
            else if (command == "delay")
            {
                int time;

                if (tokens.Count != 2)
                {
                    // Report an invalid res statement
                    AddError("'delay' statement with wring number of arguments", lineNumber);
                }
                else if ((int.TryParse(tokens[1], out time) == false) ||
                    (time < 0))
                {
                    // Report an invalid res statement
                    AddError("'delay' statement with invalid time argument '" + tokens[1] + "'", lineNumber);
                }
            }
            else if (command == "wait")
            {
                int time;

                if (tokens.Count != 3)
                {
                    // Report an invalid res statement
                    AddError("'wait' statement with wrong number of arguments", lineNumber);
                }
                else if (AddVariable(tokens[1], ScriptVariableType.Flag) == false)
                {
                    // Report an invalid map statement
                    AddError("'wait' statement redefines variable '" + tokens[1] + "'", lineNumber);
                }
                else if ((int.TryParse(tokens[2], out time) == false) ||
                    (time < 0))
                {
                    // Report an invalid res statement
                    AddError("'wait' statement with invalid time argument '" + tokens[2] + "'", lineNumber);
                }
                else
                {
                    // Add it as a used variable
                    usedVariables.Add(tokens[1].ToLower());
                }
            }
            else if (command == "call")
            {
                if (tokens.Count != 2)
                {
                    // Report an invalid call statement
                    AddError("'call' statement with with wrong number of arguments", lineNumber);
                }
                else if (tokens[1].Contains(',') ||
                    tokens[1].Intersect(Path.GetInvalidFileNameChars()).Any())
                {
                    // Report an invalid call statement
                    AddError("'call' statement with invalid script name", lineNumber);
                }
                else
                {
                    // Add this to the script's children
                    children.Add(tokens[1]);
                }
            }
            else if (command == "begin")
            {
                if (tokens.Count < 3)
                {
                    // Report an invalid begin statement
                    AddError("'begin' statement with too few arguments", lineNumber);
                }
                else if (tokens.Count > 4)
                {
                    // Report an invalid begin statement
                    AddError("'begin' statement with too many arguments", lineNumber);
                }
                else
                {
                    var directive = tokens[1].ToLower();

                    if ((directive != "atomic") && (directive != "nonatomic"))
                    {
                        // Report an invalid begin statement
                        AddError("'begin' statement with invalid argument '" + tokens[1] + "'", lineNumber);
                    }

                    int count;

                    if ((int.TryParse(tokens[2], out count) == false) || (count < 0))
                    {
                        // Report an invalid begin statement
                        AddError("'begin' statement with invalid argument '" + tokens[2] + "'", lineNumber);
                    }

                    // Check for an acknowledgement flag
                    if (tokens.Count == 4)
                    {
                        if (AddVariable(tokens[3], ScriptVariableType.Flag) == false)
                        {
                            // Report an invalid map statement
                            AddError("'map' statement redefines variable '" + tokens[3] + "'", lineNumber);
                        }
                        else
                        {
                            // Add it as a used variable
                            usedVariables.Add(tokens[3].ToLower());
                        }
                    }
                }

                return command;
            }
            else if (command == "end")
            {
                if (tokens.Count != 1)
                {
                    // Report an invalid else statement
                    AddError("'end' statement with wrong number of arguments", lineNumber);
                }

                return command;
            }
            else if (command == "endif")
            {
                if (tokens.Count != 1)
                {
                    // Report an invalid else statement
                    AddError("'end' statement with wrong number of arguments", lineNumber);
                }

                return command;
            }
            else if (command == "stepper")
            {
                int rate;
                int steps;

                if (tokens.Count < 4)
                {
                    // Report an invalid stepper statement
                    AddError("'stepper' statement with too few arguments", lineNumber);
                }
                else if ((int.TryParse(tokens[2], out rate) == false) || (rate < 0))
                {
                    // Report an invalid stepper statement
                    AddError("'stepper' statement with invalid argument '" + tokens[2] + "'", lineNumber);
                }
                else if (int.TryParse(tokens[3], out steps) == false)
                {
                    // Report an invalid stepper statement
                    AddError("'stepper' statement with invalid argument '" + tokens[3] + "'", lineNumber);
                }
                else if (tokens.Count > 5)
                {
                    // Report an invalid stepper statement
                    AddError("'stepper' statement with too many arguments", lineNumber);
                }
                else
                {
                    // Add the used variable
                    usedVariables.Add(tokens[1].ToLower());

                    if (tokens.Count == 5)
                    {
                        if (AddVariable(tokens[4], ScriptVariableType.Flag) == false)
                        {
                            // Report an invalid map statement
                            AddError("'stepper' statement redefines variable '" + tokens[4] + "'", lineNumber);
                        }
                        else
                        {
                            // Add it as a used variable
                            usedVariables.Add(tokens[4].ToLower());
                        }
                    }
                }
            }
            else if (command == "solenoid")
            {
                if (tokens.Count != 3)
                {
                    // Report an invalid res statement
                    AddError("'solenoid' statement with wrong number of arguments", lineNumber);
                }
                else
                {
                    // Check the directive
                    var directive = tokens[2].ToLower();

                    if ((directive != "on") && (directive != "off"))
                    {
                        // Report an invalid res statement
                        AddError("'solenoid' statement with invalid argument '" + tokens[2] + "'", lineNumber);
                    }
                    else
                    {
                        // Add the used variable
                        usedVariables.Add(tokens[1].ToLower());
                    }
                }
            }
            else if (command == "dpr")
            {
                if (tokens.Count < 3)
                {
                    // Report an invalid dpr statement
                    AddError("'dpr' statement with too few arguments", lineNumber);
                }
                else
                {
                    // Add the used variable
                    usedVariables.Add(tokens[1].ToLower());

                    // Check the directive
                    var directive = tokens[2].ToLower();

                    if (directive == "on")
                    {
                        int pressure;
                        int time;

                        if (tokens.Count < 4)
                        {
                            // Report an invalid dpr statement
                            AddError("'dpr' statement with too few arguments", lineNumber);
                        }
                        else if (tokens.Count > 5)
                        {
                            // Report an invalid dpr statement
                            AddError("'dpr' statement with too many arguments", lineNumber);
                        }
                        else if ((int.TryParse(tokens[3], out pressure) == false) || (pressure < 0))
                        {
                            // Report an invalid dpr statement
                            AddError("'dpr' statement with invalid argument '" + tokens[3] + "'", lineNumber);
                        }
                        else if ((tokens.Count == 5) && 
                            ((int.TryParse(tokens[4], out time) == false) || (time < 0)))
                        {
                            // Report an invalid dpr statement
                            AddError("'dpr' statement with invalid argument '" + tokens[4] + "'", lineNumber);
                        }
                    }
                    else if (directive == "off")
                    {
                        if (tokens.Count > 3)
                        {
                            // Report an invalid dpr statement
                            AddError("'dpr' off statement with too many arguments", lineNumber);
                        }
                    }
                    else
                    {
                        // Report an invalid dpr statement
                        AddError("'dpr' statement with invalid argument '" + tokens[2] + "'", lineNumber);
                    }
                }
            }
            else if (command == "if")
            {
                if (tokens.Count != 2)
                {
                    // Report an invalid if statement
                    AddError("'if' statement with wrong number of arguments", lineNumber);
                }
                else if (AddVariable(tokens[1], ScriptVariableType.Flag) == false)
                {
                    // Report an invalid map statement
                    AddError("'if' statement redefines variable '" + tokens[1] + "'", lineNumber);
                }
                else
                {
                    // Add it as a used variable
                    usedVariables.Add(tokens[1].ToLower());
                }

                return command;
            }
            else if (command == "else")
            {
                if (tokens.Count != 1)
                {
                    // Report an invalid else statement
                    AddError("'else' statement with wrong number of arguments", lineNumber);
                }

                return command;
            }
            else if (command == "throw")
            {
                if (tokens.Count < 2)
                {
                    // Report an invalid throw statement
                    AddError("'throw' statement with too few arguments", lineNumber);
                }
            }
            else if (command == "phase")
            {
                if (tokens.Count != 2)
                {
                    // Report an invalid throw statement
                    AddError("'phase' statement with wrong number of arguments", lineNumber);
                }
            }
            else if (command == "dialog")
            {
                if (tokens.Count != 3)
                {
                    // Report an invalid throw statement
                    AddError("'dialog' statement with wrong number of arguments", lineNumber);
                }
                else
                {
                    // Check the directive
                    var directive = tokens[1].ToLower();

                    if (directive != "ok")
                    {
                        // Report an invalid throw statement
                        AddError("'dialog' statement with invalid argument '" + directive + "'", lineNumber);
                    }
                }
            }
            else if (command == "set")
            {
                if (tokens.Count != 3)
                {
                    // Report an invalid throw statement
                    AddError("'set' statement with wrong number of arguments", lineNumber);
                }
                else
                {
                    // Get the metric name
                    string metric = tokens[1].ToLower();

                    int intValue;
                    bool inherited;

                    if (IDefaultMetrics.Instance.TryGetIntegerMetric(metric, out intValue, out inherited))
                    {
                        if (tokens[2].IsInteger(out intValue) == false)
                        {
                            // Report an invalid set statement
                            AddError("'set' statement with invalid argument '" + tokens[2] + "'", lineNumber);
                        }
                    }
                    else if (IDefaultMetrics.Instance.GetMetric(metric, out inherited) == null)
                    {
                        // Report an invalid set statement
                        AddError("'set' statement for unknown metric '" + metric + "'", lineNumber);
                    }
                }
            }
            else if (command == "therm")
            {
                if (tokens.Count < 3)
                {
                    // Report an invalid therm statement
                    AddError("'therm' statement with too few arguments", lineNumber);
                }
                else
                {
                    // Add the used variable
                    usedVariables.Add(tokens[1].ToLower());

                    // Check the directive
                    var directive = tokens[2].ToLower();

                    if (directive == "on")
                    {
                        int temperature;

                        if (tokens.Count < 5)
                        {
                            // Report an invalid therm statement
                            AddError("'therm' statement with too few arguments", lineNumber);
                        }
                        else if (tokens.Count > 5)
                        {
                            // Report an invalid therm statement
                            AddError("'therm' statement with too many arguments", lineNumber);
                        }
                        else if (int.TryParse(tokens[3], out temperature) == false)
                        {
                            // Report an invalid therm statement
                            AddError("'therm' statement with invalid argument '" + tokens[3] + "'", lineNumber);
                        }
                        else if (AddVariable(tokens[4], ScriptVariableType.Flag) == false)
                        {
                            // Report an invalid therm statement
                            AddError("'therm' statement redefines variable '" + tokens[4] + "'", lineNumber);
                        }
                        else
                        {
                            // Add it as a used variable
                            usedVariables.Add(tokens[4].ToLower());
                        }
                    }
                    else if (directive == "off")
                    {
                        if (tokens.Count > 3)
                        {
                            // Report an invalid therm statement
                            AddError("'therm' off statement with too many arguments", lineNumber);
                        }
                    }
                    else
                    {
                        // Report an invalid therm statement
                        AddError("'therm' statement with invalid argument '" + tokens[2] + "'", lineNumber);
                    }
                }
            }
            else if (command == "fluid")
            {
                if (tokens.Count != 3)
                {
                    // Report an invalid fluid statement
                    AddError("'fluid' statement with wrong number of arguments", lineNumber);
                }
                else
                {
                    // Add the used variable
                    usedVariables.Add(tokens[1].ToLower());

                    if (AddVariable(tokens[2], ScriptVariableType.Flag) == false)
                    {
                        // Report an invalid therm statement
                        AddError("'therm' statement redefines variable '" + tokens[2] + "'", lineNumber);
                    }
                    else
                    {
                        // Add it as a used variable
                        usedVariables.Add(tokens[2].ToLower());
                    }
                }
            }
            else if (command == "voltammetry")
            {
                if (tokens.Count < 2)
                {
                    // Report an invalid voltammetry statement
                    AddError("'voltammetry' statement with too few arguments", lineNumber);
                }
                else if (tokens[1].ToLower() == "squarewave")
                {
                    if (tokens.Count < 7)
                    {
                        // Report an invalid voltammetry statement
                        AddError("'voltammetry' statement with too few arguments", lineNumber);
                    }
                    else if (tokens.Count > 8)
                    {
                        // Report an invalid voltammetry statement
                        AddError("'voltammetry' statement with too many arguments", lineNumber);
                    }
                    else
                    {
                        int v1, v2, v3, v4, t;

                        if (int.TryParse(tokens[2], out v1) == false)
                        {
                            // Report an invalid voltammetry statement
                            AddError("'voltammetry' statement with invalid argument '" + tokens[2] + "'", 
                                lineNumber);
                        }
                        else if ((int.TryParse(tokens[3], out v2) == false) || (v2 < 0))
                        {
                            // Report an invalid voltammetry statement
                            AddError("'voltammetry' statement with invalid argument '" + tokens[3] + "'",
                                lineNumber);
                        }
                        else if ((int.TryParse(tokens[4], out v3) == false) || (v3 < 0) || (v3 > v2))
                        {
                            // Report an invalid voltammetry statement
                            AddError("'voltammetry' statement with invalid argument '" + tokens[4] + "'",
                                lineNumber);
                        }
                        else if ((int.TryParse(tokens[5], out v4) == false) || (v4 < v1))
                        {
                            // Report an invalid voltammetry statement
                            AddError("'voltammetry' statement with invalid argument '" + tokens[5] + "'",
                                lineNumber);
                        }
                        else if ((int.TryParse(tokens[6], out t) == false) || (t < 0))
                        {
                            // Report an invalid voltammetry statement
                            AddError("'voltammetry' statement with invalid argument '" + tokens[6] + "'",
                                lineNumber);
                        }
                        else if (tokens.Count == 8)
                        {
                            if (AddVariable(tokens[7], ScriptVariableType.Flag) == false)
                            {
                                // Report an invalid voltammetry statement
                                AddError("'voltammetry' statement redefines variable '" + tokens[7] + "'", lineNumber);
                            }
                            else
                            {
                                // Add it as a used variable
                                usedVariables.Add(tokens[7].ToLower());
                            }
                        }
                    }
                }
                else if (tokens[1].ToLower() == "differential")
                {
                    if (tokens.Count < 8)
                    {
                        // Report an invalid voltammetry statement
                        AddError("'voltammetry' statement with too few arguments", lineNumber);
                    }
                    else if (tokens.Count > 9)
                    {
                        // Report an invalid voltammetry statement
                        AddError("'voltammetry' statement with too many arguments", lineNumber);
                    }
                    else
                    {
                        int v1, v2, v3, v4, t1, t2;

                        if (int.TryParse(tokens[2], out v1) == false)
                        {
                            // Report an invalid voltammetry statement
                            AddError("'voltammetry' statement with invalid argument '" + tokens[2] + "'",
                                lineNumber);
                        }
                        else if ((int.TryParse(tokens[3], out v2) == false) || (v2 < 0))
                        {
                            // Report an invalid voltammetry statement
                            AddError("'voltammetry' statement with invalid argument '" + tokens[3] + "'",
                                lineNumber);
                        }
                        else if ((int.TryParse(tokens[4], out v3) == false) || (v3 < 0) || (v3 > v2))
                        {
                            // Report an invalid voltammetry statement
                            AddError("'voltammetry' statement with invalid argument '" + tokens[4] + "'",
                                lineNumber);
                        }
                        else if ((int.TryParse(tokens[5], out v4) == false) || (v4 < v1))
                        {
                            // Report an invalid voltammetry statement
                            AddError("'voltammetry' statement with invalid argument '" + tokens[5] + "'",
                                lineNumber);
                        }
                        else if ((int.TryParse(tokens[6], out t1) == false) || (t1 < 0))
                        {
                            // Report an invalid voltammetry statement
                            AddError("'voltammetry' statement with invalid argument '" + tokens[6] + "'",
                                lineNumber);
                        }
                        else if ((int.TryParse(tokens[7], out t2) == false) || (t2 < 0))
                        {
                            // Report an invalid voltammetry statement
                            AddError("'voltammetry' statement with invalid argument '" + tokens[7] + "'",
                                lineNumber);
                        }
                        else if (tokens.Count == 9)
                        {
                            if (AddVariable(tokens[8], ScriptVariableType.Flag) == false)
                            {
                                // Report an invalid voltammetry statement
                                AddError("'voltammetry' statement redefines variable '" + tokens[8] + "'", lineNumber);
                            }
                            else
                            {
                                // Add it as a used variable
                                usedVariables.Add(tokens[8].ToLower());
                            }
                        }
                    }
                }
                else
                {
                    // Report an invalid voltammetry statement
                    AddError("'voltammetry' statement with invalid argument '" + tokens[1] + "'", lineNumber);
                }
            }
            else if (command == "peak")
            {
                if (tokens.Count < 2)
                {
                    // Report an invalid peak statement
                    AddError("'peak' statement with too few arguments", lineNumber);
                }
                else if (tokens[1].ToLower() == "algorithm")
                {
                    if (tokens.Count < 3)
                    {
                        // Report an invalid peak statement
                        AddError("'peak' statement with too few arguments", lineNumber);
                    }
                    else
                    {
                        // Try to create an analysis object
                        if (IAnalysis.Create(tokens[2].StringValue(), 
                            tokens.GetRange(3, tokens.Count - 3).ToArray()) == null)
                        {
                            // Report an invalid peak statement
                            AddError("'peak' statement with invalid arguments", lineNumber);
                        }
                    }
                }
                else if (tokens[1].ToLower() == "define")
                {
                    if (tokens.Count < 13)
                    {
                        // Report an invalid peak statement
                        AddError("'peak' statement with too few arguments", lineNumber);
                    }
                    else
                    {
                        string peakType = tokens[3].ToLower();
                        int potentiostat;
                        double minPotential, maxPotential, mean, tolerance, lowerLimit, upperLimit,
                            maxVarianceForCurveFit, topPercentageForCurveFit;

                        if ((peakType != "ignore") && (peakType != "rescan") &&
                            (peakType != "positive") && (peakType != "negative"))
                        {
                            // Report an invalid peak statement
                            AddError("'peak' statement with invalid argument '" + tokens[3] + "'", 
                                lineNumber);
                        }
                        else if ((int.TryParse(tokens[4], out potentiostat) == false) ||
                            (potentiostat < 1) || (potentiostat > 4))
                        {
                            // Report an invalid peak statement
                            AddError("'peak' statement with invalid argument '" + tokens[4] + "'",
                                lineNumber);
                        }
                        else if (double.TryParse(tokens[5], out minPotential) == false)
                        {
                            // Report an invalid peak statement
                            AddError("'peak' statement with invalid argument '" + tokens[5] + "'",
                                lineNumber);
                        }
                        else if ((double.TryParse(tokens[6], out maxPotential) == false) ||
                            (maxPotential < minPotential))
                        {
                            // Report an invalid peak statement
                            AddError("'peak' statement with invalid argument '" + tokens[6] + "'",
                                lineNumber);
                        }
                        else if ((double.TryParse(tokens[7], out mean) == false) ||
                            (mean < minPotential) || (mean > maxPotential))
                        {
                            // Report an invalid voltammetry statement
                            AddError("'peak' statement with invalid argument '" + tokens[7] + "'",
                                lineNumber);
                        }
                        else if ((double.TryParse(tokens[8], out tolerance) == false) ||
                            (tolerance < 0))
                        {
                            // Report an invalid peak statement
                            AddError("'peak' statement with invalid argument '" + tokens[8] + "'",
                                lineNumber);
                        }
                        else if ((double.TryParse(tokens[9], out lowerLimit) == false) ||
                            (lowerLimit < 0))
                        {
                            // Report an invalid peak statement
                            AddError("'peak' statement with invalid argument '" + tokens[9] + "'",
                                lineNumber);
                        }
                        else if ((double.TryParse(tokens[10], out upperLimit) == false) ||
                            (upperLimit < lowerLimit))
                        {
                            // Report an invalid peak statement
                            AddError("'peak' statement with invalid argument '" + tokens[10] + "'",
                                lineNumber);
                        }
                        else if ((double.TryParse(tokens[11], out maxVarianceForCurveFit) == false) ||
                            (maxVarianceForCurveFit < 0))
                        {
                            // Report an invalid peak statement
                            AddError("'peak' statement with invalid argument '" + tokens[11] + "'",
                                lineNumber);
                        }
                        else if ((double.TryParse(tokens[12], out topPercentageForCurveFit) == false) ||
                            (topPercentageForCurveFit < 0) || (topPercentageForCurveFit > 100))
                        {
                            // Report an invalid peak statement
                            AddError("'peak' statement with invalid argument '" + tokens[12] + "'",
                                lineNumber);
                        }
                    }
                }
                else
                {
                    // Report an invalid peak statement
                    AddError("'peak' statement with invalid argument '" + tokens[1] + "'", 
                        lineNumber);
                }
            }
            else if (command == "buzzer")
            {
                if (tokens.Count != 4)
                {
                    // Report an invalid res statement
                    AddError("'buzzer' statement with wrong number of arguments", lineNumber);
                }
                else
                {
                    int p, d, t;

                    if ((int.TryParse(tokens[1], out p) == false) || (p < 1))
                    {
                        // Report an invalid res statement
                        AddError("'buzzer' statement with invalid argument '" + tokens[1] + "'", lineNumber);
                    }
                    else if ((int.TryParse(tokens[2], out d) == false) || (d < 1) || (d > 100))
                    {
                        // Report an invalid res statement
                        AddError("'buzzer' statement with invalid argument '" + tokens[2] + "'", lineNumber);
                    }
                    else if ((int.TryParse(tokens[3], out t) == false) || (t < 1))
                    {
                        // Report an invalid res statement
                        AddError("'buzzer' statement with invalid argument '" + tokens[3] + "'", lineNumber);
                    }
                }
            } 
            else if (command == "regvalve") 
            {
                int millivolts;

                if (tokens.Count != 2) 
                {
                    // Report an invalid regvalve statement
                    AddError("'regvalve' statement with wrong number of arguments", lineNumber);
                } 
                else if ((int.TryParse(tokens[1], out millivolts) == false) || (millivolts < 0)) 
                {
                    // Report an invalid regvalve statement
                    AddError("'regvalve' statement with invalid millivolts argument '" + tokens[1] + "'", lineNumber);
                }
            } 
            else if (command == "preport") 
            {
                if (tokens.Count != 2) 
                {
                    // Report an invalid res statement
                    AddError("'preport' statement with wrong number of arguments", lineNumber);
                } 
				else 
                {
                    // Check the directive
                    var directive = tokens[1].ToLower();

                    if ((directive != "on") && (directive != "off")) 
                    {
                        // Report an invalid preport statement
                        AddError("'preport' statement with invalid argument '" + tokens[1] + "'", lineNumber);
                    }
                }
            }
            else if (command == "pstat")
            {
                if (tokens.Count != 3 && tokens.Count != 1)
                {
                    // Report an invalid pstat statement
                    AddError("'pstat' statement with wrong number of arguments", lineNumber);
                }
                else
                {
                    if (tokens.Count == 3)
                    {
                        int millivolts;
                        var directive = tokens[1].ToLower();
                        string loadType = tokens[2].ToLower();

                        if ((int.TryParse(tokens[1], out millivolts) == false) || (millivolts < 0))
                        {
                            // Report an invalid pstat statement
                            AddError("'pstat' statement with invalid millivolts argument '" + tokens[1] + "'", lineNumber);
                        }
                        if ((loadType != "internal") && (loadType != "external"))
                        {
                            // Report an invalid pstat statement
                            AddError("'pstat' statement with invalid argument '" + tokens[2] + "'", lineNumber);
                        }
                    }
                }
            }
            else if (command == "peltier")
            {
                if (tokens.Count != 2)
                {
                    // Report an invalid res statement
                    AddError("'peltier' statement with wrong number of arguments", lineNumber);
                }
                else
                {
                    // Check the directive
                    var directive = tokens[1].ToLower();

                    if ((directive != "heat") && (directive != "cool") && (directive != "off"))
                    {
                        // Report an invalid peltier statement
                        AddError("'peltier' statement with invalid argument '" + tokens[1] + "'", lineNumber);
                    }
                }
            }
            else if (command == "psensor")
            {
                if (tokens.Count != 1)
                {
                    // Report an invalid psensor statement
                    AddError("'psensor' statement with wrong number of arguments", lineNumber);
                }
            }
            else
            {
                // Report an unrecognised command
                AddError("Unrecognised command '" + tokens[0] + "'", lineNumber);
            }

            return null;
        }
    }
}
